---------------------------------------------------------------------------
-- Vérification des types                                                --
---------------------------------------------------------------------------

-- `check c Γ e` renvoie le type de `e` dans l'environnement `Γ`.
-- Si `c` est vrai, on fait une vérification complète, alors que s'il
-- est faux, alors on présume que le code est typé correctement et on
-- se contente de chercher le type.

-- *** Probablement utile pour le rapport :  On veut écrire une fonction pour vérifier le typage de façon statique 
-- dans le langage SSlip. Elle traduit les règles théoriques en une implémentation pratique, nous obligeant à comprendre, 
-- formaliser et appliquer les concepts de typage et d’analyse syntaxique en Haskell. La fonction "check" est utilisée pour 
-- vérifier le typage des expressions dans le langage SSlip. Elle prend une expression (Lexp), un environnement de typage (TEnv), 
-- et détermine si cette expression est correctement typée selon les règles de typage définies (Figure 2). Si l’expression est valide,
-- elle renvoie son type (Type), sinon, elle retourne une erreur (Terror) expliquant le problème. Cela garantit que les programmes 
-- écrits en SSlip respectent les règles du typage statique avant leur exécution. ***

type TEnv = [(Var, Type)]

toTEnv :: Env -> TEnv
toTEnv env = map (\(var, typ, _) -> (var, typ)) env


check :: Bool -> TEnv -> Lexp -> Type
check _ _ (Lnum _) = Tnum
check _ _ (Lbool _) = Tbool
-- Variables
check _ env (Lvar x) =
    case lookup x env of
        Just t -> t
        Nothing -> Terror ("Variable inconnue: " ++ x)

-- Annotation de type
check True env (Ltype e tp) =
    let t = check True env e
    in if t == tp then tp else Terror ("Mauvais type: attendu "
                                    ++ show tp
                                    ++ ", obtenu "
                                    ++ show t)
check False _ (Ltype _ tp) = tp

-- Déclaration locale let x e1 e2
check True env (Llet x e1 e2) =
    let t1 = check True env e1
    in if t1 == Terror "Expression inconnue"
       then Terror ("Erreur dans Llet : " ++ x ++ " a un type invalide")
       else check True ((x, t1) : env) e2

check True env (Ltest e1 e2 e3) =
    case check True env e1 of
        Tbool ->
            let t2 = check True env e2
                t3 = check True env e3
            in if t2 == t3 
                then t2 
                else Terror "Branches de if de types différents"
        t -> Terror ("Condition de if n'est pas un booléen, obtenu : " 
                    ++ show t)


-- Appel de fonction
check True env (Lsend f args) =
    case check True env f of
        Tfob argTypes returnType ->
            if length args == length argTypes
            then
                let argChecks = zipWith checkType args argTypes
                in if and argChecks
                    then returnType
                    else Terror ("Types des arguments incorrects dans Lsend: " 
                                ++ show args 
                                ++ " attendu : " 
                                ++ show argTypes)
            else Terror ("Nombre d'arguments incorrect pour Lsend : attendu " 
                                ++ show (length argTypes) 
                                ++ ", obtenu : " 
                                ++ show (length args))
        t -> Terror ("Expression appelee n'est pas une fonction, type obtenu: " 
                    ++ show t)
    where 
        checkType :: Lexp -> Type -> Bool
        checkType arg expectedType = check True env arg == expectedType

-- Déclaration de fonction
check True env (Lfob args body) =
    let argEnv = [(x, t) | (x, t) <- args]
        fullEnv = argEnv ++ env
    in case check True fullEnv body of
        Terror msg -> Terror ("Erreur dans le corps de Lfob : " ++ msg)
        t -> Tfob (map snd args) t

-- Déclaration locale récursive
check True env (Lfix decls body) =
    let
        -- Étape 1 : Environnement temporaire avec des types par défaut
        initEnv = [(x, Tfob (map snd args) Tnum) | (x, Lfob args _) <- decls]

        -- Étape 2 : Raffinement des types dans l'environnement progressif
        refineEnv :: TEnv -> [(Var, Lexp)] -> TEnv
        refineEnv currentEnv [] = currentEnv
        refineEnv currentEnv ((x, Lfob args body):rest) =
            let argEnv = [(argName, argType) | (argName, argType) <- args]
                fullEnv = argEnv ++ currentEnv ++ env
                t = check True fullEnv body
            in refineEnv ((x, Tfob (map snd args) t) : currentEnv) rest
        refineEnv _ _ = error "Erreur de structure dans Lfix"

        refinedEnv = refineEnv initEnv decls

        -- Étape 3 : Vérification de chaque déclaration avec l'environnement raffiné
        validateDecls = all (\(x, Lfob args body) ->
            let argEnv = [(argName, argType) | (argName, argType) <- args]
                t = check True (argEnv ++ refinedEnv ++ env) body
            in t /= Terror "Expression inconnue") decls
    in if validateDecls
       then check True (refinedEnv ++ env) body
       else Terror "Erreur dans les déclarations récursives"


-- Cas par défaut
check _ _ _ = Terror "Expression inconnue"

