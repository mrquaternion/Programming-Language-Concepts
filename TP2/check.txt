---------------------------------------------------------------------------
-- Vérification des types                                                --
---------------------------------------------------------------------------

-- `check c Γ e` renvoie le type de `e` dans l'environnement `Γ`.
-- Si `c` est vrai, on fait une vérification complète, alors que s'il
-- est faux, alors on présume que le code est typé correctement et on
-- se contente de chercher le type.

-- *** Probablement utile pour le rapport :  On veut écrire une fonction pour vérifier le typage de façon statique 
-- dans le langage SSlip. Elle traduit les règles théoriques en une implémentation pratique, nous obligeant à comprendre, 
-- formaliser et appliquer les concepts de typage et d’analyse syntaxique en Haskell. La fonction "check" est utilisée pour 
-- vérifier le typage des expressions dans le langage SSlip. Elle prend une expression (Lexp), un environnement de typage (TEnv), 
-- et détermine si cette expression est correctement typée selon les règles de typage définies (Figure 2). Si l’expression est valide,
-- elle renvoie son type (Type), sinon, elle retourne une erreur (Terror) expliquant le problème. Cela garantit que les programmes 
-- écrits en SSlip respectent les règles du typage statique avant leur exécution. ***

type TEnv = [(Var, Type)]

toTEnv :: Env -> TEnv
toTEnv env = map (\(var, typ, _) -> (var, typ)) env

-- Vérification des types
check :: Bool -> TEnv -> Lexp -> Type

-- Constantes
check _ _ (Lnum _) = Tnum
check _ _ (Lbool _) = Tbool

-- Variables
check _ env (Lvar x) =
    case lookup x env of
        Just t -> t
        Nothing -> Terror ("Variable inconnue: " ++ x)

-- Annotation de type
check True env (Ltype e τ) =
    let t = check True env e
    in if t == τ then τ else Terror ("Type mismatch: attendu " ++ show τ ++ ", obtenu " ++ show t)
check False _ (Ltype _ τ) = τ

-- Déclaration locale let x e1 e2
check True env (Llet x e1 e2) =
    let t1 = check True env e1
    in trace ("Llet: " ++ x ++ " has type " ++ show t1 ++ " in env " ++ show env) $
       if t1 == Terror "Expression inconnue"
       then Terror ("Erreur dans Llet : " ++ x ++ " a un type invalide")
       else check True ((x, t1) : env) e2

check True env (Ltest e1 e2 e3) =
    case check True env e1 of
        Tbool -> 
            let t2 = check True env e2
                t3 = check True env e3
            in trace ("Ltest branches: " ++ show t2 ++ ", " ++ show t3) $
               if t2 == t3 then t2 else Terror "Branches de if de types différents"
        t -> Terror ("Condition de if n'est pas un booléen, obtenu : " ++ show t)


-- Appel de fonction
check True env (Lsend f args) =
    case check True env f of
        Tfob argTypes returnType ->
            if length args == length argTypes
            then 
                let argChecks = zipWith (\arg expectedType -> check True env arg == expectedType) args argTypes
                in if all id argChecks
                    then returnType
                    else Terror ("Types des arguments incorrects dans Lsend: " ++ show args ++ " attendu: " ++ show argTypes)
            else Terror ("Nombre d'arguments incorrect pour Lsend : attendu " ++ show (length argTypes) ++ ", obtenu " ++ show (length args))
        t -> Terror ("Expression appelee n'est pas une fonction, type obtenu : " ++ show t)

-- Déclaration de fonction
check True env (Lfob args body) =
    let argEnv = [(x, t) | (x, t) <- args]
        fullEnv = argEnv ++ env
    in case check True fullEnv body of
        Terror msg -> Terror ("Erreur dans le corps de Lfob : " ++ msg)
        t -> Tfob (map snd args) t

-- Déclaration locale récursive
check True env (Lfix decls body) =
    let 
        -- Étape 1 : Environnement temporaire
        initEnv = [(x, Tfob (map (const Tnum) args) Tnum) | (x, Lfob args _) <- decls]

        -- Étape 2 : Raffinement des types
        refineEnv :: TEnv -> [(Var, Lexp)] -> TEnv
        refineEnv currentEnv [] = currentEnv
        refineEnv currentEnv ((x, Lfob args body):rest) =
            let argEnv = [(argName, argType) | (argName, argType) <- args]
                fullEnv = argEnv ++ currentEnv ++ env
                t = check True fullEnv body
            in refineEnv ((x, Tfob (map snd args) t) : currentEnv) rest

        fullEnv = refineEnv initEnv decls

        -- Étape 4 : Vérification des déclarations
        verifyDecls = all (\(x, Lfob args body) -> 
            let argEnv = [(argName, argType) | (argName, argType) <- args]
                t = check True (argEnv ++ fullEnv ++ env) body
            in t /= Terror "Expression inconnue") decls
    in if verifyDecls
       then check True (fullEnv ++ env) body
       else Terror "Erreur dans les déclarations récursives"

-- Cas par défaut
check _ _ _ = Terror "Expression inconnue"
