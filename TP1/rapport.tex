\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[a4paper, left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{enumitem}


\title{Rapport TP1 - Langage SLIP}
\author{Mathias La Rochelle \& Michel Lamothe}
\date{Le samedi 29 septembre 2024}

\begin{document}

\maketitle
\setlength{\parindent}{0pt}


\section{Introduction}
\subsection{Objectifs du TP}
Afin d'avoir une session interactive sur GHCi avec aucuns avertissements et aucunes exceptions, nous allons devoir compléter les fonctions \textit{s2l} et \textit{eval}. Nous devons également écrire le code d'au moins 5 tests dans un fichier \texttt{tests.slip}. Tout doit bien s'exécuter évidemment. \\

\noindent À noter que le tout doit bien s'exécuter sur les machines du laboratoire du DIRO à travers une connexion SSH avec \texttt{ens.iro}.

\subsection{Présentation du langage SLIP}
Le langage SLIP est un langage qui se rapproche fortement de la famille de langages Lisp. Il s'agit d'un langage fonctionnel conçu pour être simple et expressif, tout en conservant certaines caractéristiques clés de Lisp. SLIP utilise une syntaxe basée sur les expressions S. Nous allons explorer en profondeur le fonctionnement interne de SLIP en implémentant ses composants essentiels.

\subsection{Structure du rapport}
Ce rapport est organisé de la manière suivante :
\begin{itemize}
    \item La section 2 présente l'implémentation des fonctions principales, notamment \textit{s2l} et \textit{eval}.
    \item La section 3 détaille les exemples et les tests réalisés pour valider notre implémentation.
    \item La section 4 discute des difficultés rencontrées et des solutions apportées.
    \item La section 5 conclut le rapport en résumant nos réalisations et en proposant des pistes d'amélioration.
\end{itemize}

Tout au long de ce rapport, nous mettrons en évidence les concepts clés du langage SLIP et les choix d'implémentation effectués pour répondre aux exigences du TP. \\

\section{Implémentation}
Dans ce projet, l’objectif est d’implémenter une variante simplifiée de "Lisp" en utilisant Haskell. L’implémentation repose sur deux parties principales : la conversion des expressions symboliques "Sexp" vers une forme simplifiée "Lexp", et l’évaluation de ces expressions dans un environnement d’exécution. Nous avons dû construire deux fonctions manquantes, \texttt{s2l} et \texttt{eval}, pour assurer que le code fonctionne correctement en convertissant et évaluant les expressions de manière cohérente.\\

Après avoir analysé l’expression symbolique \texttt{Sexp}, nous devons la transformer en une forme de logique de programmation (\texttt{Lexp}), puis l'évaluée pour produire un résultat à l’exécution. L'implémentation met en jeu des concepts fondamentaux comme la définition de variables, l'évaluation d'expressions conditionnelles, les fonctions récursives et les appels de fonctions.

\subsection{Structures de données utilisées}

\texttt{Sexp} : Cette structure de données représente les expressions du langage que nous manipulons. Elle permet de représenter les entiers, les symboles et les listes imbriquées de manière récursive.
\begin{itemize}
    \item \texttt{Snil} : Représente une liste vide.
    \item \texttt{Ssym String} : Représente un symbole sous forme de chaîne de caractères.
    \item \texttt{Snum Int} : Représente un entier.
    \item \texttt{Snode Sexp [Sexp]} : Représente une liste non vide d’expressions.
\end{itemize}

\texttt{Lexp} : C’est la forme intermédiaire d’une expression après analyse syntaxique. Elle simplifie les calculs et facilite l'évaluation.
\begin{itemize}
    \item \texttt{Lnum Int} : Constante entière.
    \item \texttt{Lbool Bool} : Constante booléenne.
    \item \texttt{Lvar Var} : Référence à une variable.
    \item \texttt{Ltest Lexp Lexp Lexp} : Expression conditionnelle (équivalente à if).
    \item \texttt{Lfob [Var] Lexp} : Définition d'une fonction (objet fonctionnel).
    \item \texttt{Lsend Lexp [Lexp]} : Appel de fonction avec arguments.
    \item \texttt{Llet Var Lexp Lexp} : Déclaration locale non récursive.
    \item \texttt{Lfix [(Var, Lexp)] Lexp} : Déclaration de variables mutuellement récursives. \newline
\end{itemize} 

\texttt{VEnv :} Une liste de paires (Var, Value) où Var est le nom d’une variable et Value est la valeur correspondante. Utilisée dans l’évaluation pour suivre les variables définies et leur portée. \newline

\texttt{Value :} Représente les différentes valeurs que peut manipuler le langage lors de l’exécution.
\begin{itemize}
    \item \texttt{Vnum Int} : Entier.
    \item \texttt{Vbool Bool} : Booléen.
    \item \texttt{Vbuiltin ([Value] -> Value)} : Fonction primitive (comme + ou -).
    \item \texttt{Vfob VEnv [Var] Lexp} : Objet fonctionnel avec un environnement.
\end{itemize}

\subsection{Fonctions principales}
\texttt{s2l (Conversion de Sexp vers Lexp) :} La fonction s2l convertit une expression de type Sexp une expression logique Lexp. Cette conversion permet de simplifier la manipulation et l’évaluation des expressions.
La façon dont s2l est implémenté :
\begin{itemize}
    \item L’analyse commence par un pattern matching sur les différentes formes de Sexp.
    \item Si l’expression est un entier (Snum), elle est convertie en Lnum.
    \item Si l’expression est une fonction comme "let", elle est transformée en une structure de type "Llet".
    \item En cas de liste vide "Snil", la fonction "Lfob" est utilisée pour définir un objet fonctionnel avec une liste vide de paramètres.
\end{itemize}
\texttt{Exemple} : s2l (Snode (Ssym "let") [Ssym "x", Snum 2, Snode (Ssym "+") [Lvar "x", Lnum 3]])

\hspace{1cm}\texttt{Résultat} : Llet "x" (Lnum 2) (Lsend (Lvar "+") [Lvar "x", Lnum 3])


\subsection{Difficultés rencontrées et solutions}

\begin{enumerate}
    \item \texttt{Problème :} Extraction des arguments et liaisons récursives
        \begin{itemize}
            \item \texttt{Description :} Lors de la conversion avec Lfix, il a été difficile d’extraire correctement les variables et leur corps.
            \item \texttt{Solution :} L’utilisation de fonctions auxiliaires (bindExtraction et argsExtraction) a permis de gérer efficacement les expressions imbriquées et de structurer les arguments de manière cohérente.
        \end{itemize}
        
    \item \texttt{Problème :} Gestion de l'environnement d’exécution
        \begin{itemize}
            \item \texttt{Description :} Il était complexe de maintenir un suivi précis de l’environnement avec des déclarations imbriquées. Par exemple, les variables définies dans un "let" ne doivent pas affecter l’environnement global.
            \item \texttt{Solution :} L’approche consistant à ajouter temporairement des variables dans l’environnement a permis de résoudre ce problème sans modifier les environnements globaux. L’utilisation de listes immuables pour représenter l'environnement a également facilité la gestion.
        \end{itemize}
    \item \texttt{Problème :} Gestion de l'environnement d’exécution
        \begin{itemize}
            \item \texttt{Description :} La gestion des fonctions et objets fonctionnels définis avec Lfob posait plusieurs défis. Contrairement à un simple appel de fonction, Lfob permet de définir une fonction en capturant un environnement local (appelé closure). Cela signifie que la fonction peut être appelée plus tard avec des arguments, en se basant sur les variables définies lors de sa création. Cependant, plusieurs problèmes sont apparus :
                \begin{enumerate}[label=\roman*.]
                    \item \texttt{Correspondance des paramètres et arguments :} Il fallait s'assurer que le nombre de paramètres fournis lors de l’appel corresponde exactement au nombre d'arguments attendus par la fonction.
                    \item \texttt{Gestion de l’environnement capturé :} L’environnement d’exécution lors de la définition de la fonction devait être stocké et réutilisé lorsque la fonction était appelée.
                    \item \texttt{Appels imbriqués :} Dans certains cas, une fonction pouvait retourner une autre fonction, ce qui nécessitait une gestion des closures imbriquées.
                    \item \texttt{Traitement des erreurs :} Une mauvaise correspondance entre les paramètres et les arguments devait être signalée immédiatement avec un message d'erreur explicite.
                \end{enumerate}
            \item \texttt{Solution :} 
                \begin{enumerate}[label=\roman*.]
                    \item \texttt{Validation du nombre d'arguments :} Lors de l’évaluation d’une fonction avec Lsend, une vérification explicite a été ajoutée pour s'assurer que le nombre d'arguments correspond au nombre de paramètres. En cas de déséquilibre, une erreur descriptive est levée:\newline
                    \hspace*{1cm}**if length params == length args\newline
                    \hspace*{1cm}then ...\newline
                    \hspace*{1cm}else error ("Manque " ++ show (abs (length params - length args))\newline\hspace*{2cm} ++ " arguments.")**

                    \item \texttt{Gestion de l’environnement capturé :} L’environnement d’exécution lors de la définition de la fonction devait être stocké et réutilisé lorsque la fonction était appelée.
                    \item \texttt{Appels imbriqués :} Dans certains cas, une fonction pouvait retourner une autre fonction, ce qui nécessitait une gestion des closures imbriquées.
                    \item \texttt{Traitement des erreurs :} Une mauvaise correspondance entre les paramètres et les arguments devait être signalée immédiatement avec un message d'erreur explicite.
                \end{enumerate}
        \end{itemize}
    \item La section 5 conclut le rapport en résumant nos réalisations et en proposant des pistes d'amélioration.
\end{enumerate}


Je ne sais pas :(

\newpage 
\section{Exemples et tests} 
\subsection{Cas de test simples} 
\subsubsection*{Test 1 : Fonction sans paramètre} 
\hspace{.5cm}\textbf{Expression :} 
\begin{verbatim} 
    (fob () 42)) 
\end{verbatim} 
\hspace{.5cm}\textbf{Explications :} 
\begin{itemize} 
    \item Teste la création et l'appel d'une fonction sans paramètre. 
    \item Vérifie que la fonction retourne bien la valeur 42. 
\end{itemize}
\subsubsection*{Test 2 : Fonction avec paramètre simple} 
\hspace{.5cm}\textbf{Expression :} 
\begin{verbatim} 
    ((fob (x) (if (= x 5) true false)) 5) 
\end{verbatim} 
\hspace{.5cm}\textbf{Explications :} 
\begin{itemize} 
    \item Teste une fonction qui prend un paramètre. 
    \item Vérifie si le paramètre vaut 5 pour retourner \texttt{true}, sinon \texttt{false}. 
\end{itemize}
\subsubsection*{Test 3 : Fonction avec let et fermeture} 
\hspace{.5cm}\textbf{Expression :} 
\begin{verbatim} 
    (let x 5 ((fob (x) (+ x 3)) x)) 
\end{verbatim} 
\hspace{.5cm}\textbf{Explications :} 
\begin{itemize} 
    \item Déclare une variable \texttt{x} locale avec la valeur 5. 
    \item Appelle une fonction qui ajoute 3 à \texttt{x} et retourne le résultat. 
\end{itemize}

\subsection{Cas de test complexes}
\subsubsection*{Test 4 : Fonction récursive (factorielle)} 
\hspace{.5cm}\textbf{Expression :} 
\begin{verbatim} 
    (fix ((fact (fob (n) 
                        (if (= n 0) 1 
                        (* n (fact (- n 1))))))) 
         (fact 5)) 
\end{verbatim} 
\hspace{.5cm}\textbf{Explications :} 
\begin{itemize} 
    \item Teste la récursion pour calculer la factorielle de 5. 
    \item Vérifie que la base de récursion (\texttt{n = 0}) retourne 1. 
\end{itemize}
\subsubsection*{Test 5 : Fonction imbriquée avec trois paramètres} 
\hspace{.5cm}\textbf{Expression :} 
\begin{verbatim} 
    (let volume ((((fob (x) (fob (y) (fob (z) (* x (* y z))))) 3) 2) 4) 
                (if (= volume 16) true false))
\end{verbatim} 
\hspace{.5cm}\textbf{Explications :} 
\begin{itemize} 
    \item Teste une fonction imbriquée prenant trois paramètres (\texttt{x}, \texttt{y}, \texttt{z}). 
    \item Calcule \texttt{volume} et vérifie si la valeur obtenue est 16. 
\end{itemize}
%\subsection{Analyse des résultats}
%\subsubsection*{Résumé des concepts couverts}
%\begin{enumerate}
%\item \texttt{Lnum} et \texttt{Lbool} : Testés implicitement dans les tests 1, 2, 3, et 5.
%\item \texttt{Lvar} : Testé dans le test 1 avec l'accès à la variable x.
%\item \texttt{Llet} : Déclaration de variable locale, testée dans le test 1.
%\item \texttt{Lfob} et \texttt{Lsend} : Gestion des fonctions avec ou sans paramètres, testées dans les tests 4 et 5.
%\item \texttt{Ltest} : Conditions avec if, testées dans le test 2 et la récursion (test 3).
%\item \texttt{Lfix} : Gestion de la récursivité, testée dans le test 3.
%\item Appels imbriqués et environnements : Testés dans les tests 4 et 5.
%\end{enumerate}

\newpage
\section*{Extension du langage}
\subsection*{Nouvelles fonctionnalités implémentées}
\subsection*{Justification des choix}

\section*{Conclusion}
\subsection*{Récapitulatif des réalisations}
\subsection*{Perspectives d'amélioration}

\section*{Annexes}
\subsection*{Code source complet}
\subsection*{Exemples supplémentaires}

\end{document}

